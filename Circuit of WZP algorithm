import numpy as np
import math
from math import pi
from qiskit import QuantumCircuit as QCirc, ClassicalRegister as CReg, QuantumRegister as QReg, execute as exe
from qiskit.tools.visualization import circuit_drawer as CDraw
from qiskit.quantum_info import state_fidelity as SFad 
from qiskit import BasicAer as BAer
from qiskit.tools.visualization import matplotlib_circuit_drawer as drawer, qx_color_scheme
#A=[1 2; 2, 1] b=[1; 0]
#x=[2/3; -1/3]->[0.8945,-0.4472]

qr = QReg(5)                                                #create 3 quantum register named qr
cr = CReg(1)                                                 #create 2 quantum register named cr
c = QCirc(qr,cr)                                            #create quantum circuit for qr and cr named c

#v=[1/math.sqrt(2), 0, 0, 0, 1/math.sqrt(2), 0, 0, 0,
#  0, 0, 0, 0, 0, 0, 0, 0]
#c.initialize(v,[qr[0],qr[1],qr[2],qr[3]])

c.h(qr[3]) #QRAM

c.h(qr[1])
c.h(qr[2]) #QPE multiple H

c.cu3(-1.2025,+2.1112,-1.0304,qr[3],qr[4])
c.u1(+0.7854,qr[3])
c.cx(qr[2],qr[3]) #Q1
c.cu3(-1.2025,-2.1112,+1.0304,qr[3],qr[4])
c.u1(-0.7854,qr[3])
c.cx(qr[2],qr[3]) #Q2
c.cu3(-1.2025,+2.1112,-1.0304,qr[2],qr[4])
c.u1(+0.7854,qr[2])
c.cx(qr[2],qr[3]) #Q3
c.cu3(+1.2025,-2.1112,+1.0304,qr[3],qr[4])
c.u1(+0.7854,qr[3])
c.cx(qr[2],qr[3]) #Q4
c.cu3(+1.2025,+2.1112,-1.0304,qr[3],qr[4])
c.u1(-0.7854,qr[3])
c.cx(qr[2],qr[3]) #Q5
c.cu3(+1.2025,-2.1112,+1.0304,qr[2],qr[4])
c.u1(+0.7854,qr[2])#Q6

c.cx(qr[1],qr[3])
c.cu3(-1.2870,0,0,qr[3],qr[4]) #Q1_
c.cx(qr[1],qr[3])
c.cu3(+1.2870,0,0,qr[3],qr[4]) #Q2_
c.cx(qr[1],qr[3])
c.cu3(-1.2870,0,0,qr[1],qr[4]) #Q3_
c.cx(qr[1],qr[3])
c.cu3(+1.2870,0,0,qr[3],qr[4]) #Q4_
c.cx(qr[1],qr[3])
c.cu3(-1.2870,0,0,qr[3],qr[4]) #Q5_
c.cx(qr[1],qr[3])
c.cu3(+1.2870,0,0,qr[1],qr[4]) #Q6_

c.swap(qr[1],qr[2])
c.h(qr[2])
c.cu3(0,-pi/2,0,qr[2],qr[1])
c.u1(-pi/4,qr[2])
c.h(qr[1]) #QFT^H

c.h(qr[3]) #QRAM^H

#c.u3(1.25,0,0,qr[0])
p=1.4
c.cu3(p,0,0,qr[1],qr[0])
c.cu3(p/2,0,0,qr[2],qr[0]) #control rotation

#REVERSED CIRCUIT
c.h(qr[3]) #QRAM
c.h(qr[1]) 
c.u1(+pi/4,qr[2])
c.cu3(0,+pi/2,0,qr[2],qr[1])
c.h(qr[2])
c.swap(qr[1],qr[2])#QFT
c.cu3(-1.2870,0,0,qr[1],qr[4]) #Q6_
c.cx(qr[1],qr[3])
c.cu3(+1.2870,0,0,qr[3],qr[4]) #Q5_
c.cx(qr[1],qr[3])
c.cu3(-1.2870,0,0,qr[3],qr[4]) #Q4_
c.cx(qr[1],qr[3])
c.cu3(+1.2870,0,0,qr[1],qr[4]) #Q3_
c.cx(qr[1],qr[3])
c.cu3(-1.2870,0,0,qr[3],qr[4]) #Q2_
c.cx(qr[1],qr[3])
c.cu3(+1.2870,0,0,qr[3],qr[4]) #Q1_
c.cx(qr[1],qr[3])
c.u1(-0.7854,qr[2])#Q6
c.cu3(1.2025,+2.1112,-1.0304,qr[2],qr[4])
c.cx(qr[2],qr[3])
c.u1(+0.7854,qr[3])#Q5
c.cu3(+1.2025,-2.1112,+1.0304,qr[3],qr[4])
c.cx(qr[2],qr[3])
c.u1(-0.7854,qr[3])#Q4
c.cu3(+1.2025,+2.1112,-1.0304,qr[3],qr[4])
c.cx(qr[2],qr[3])
c.u1(-0.7854,qr[2])#Q3
c.cu3(-1.2025,-2.1112,+1.0304,qr[2],qr[4])
c.cx(qr[2],qr[3]) 
c.u1(+0.7854,qr[3]) #Q2
c.cu3(-1.2025,+2.1112,-1.0304,qr[3],qr[4])
c.cx(qr[2],qr[3])
c.u1(-0.7854,qr[3]) #Q1
c.cu3(-1.2025,-2.1112,+1.0304,qr[3],qr[4])
c.h(qr[1])
c.h(qr[2]) #QPE^H multiple H
c.h(qr[3])

c.measure(qr[0],cr[0])
c.reset(qr[0])
#c.x(qr[0])

c.draw(output='mpl')

Usim = BAer.get_backend('statevector_simulator')
job = exe(c, Usim)
x=job.result().get_statevector(c)
for i in range(32):
    x[i]=round(x[i],5)#print(x)
X=[0, 0]
a=16; b=22
X[0]=round(np.real(x[a]/math.sqrt(x[a]*np.conjugate(x[a])+x[b]*np.conjugate(x[b]))),5)
X[1]=round(np.real(x[b]/math.sqrt(x[a]*np.conjugate(x[a])+x[b]*np.conjugate(x[b]))),5)
print(X)

backend = BAer.get_backend('qasm_simulator')
job = exe(c, backend, shots=1024)
job.result().get_counts(c)
